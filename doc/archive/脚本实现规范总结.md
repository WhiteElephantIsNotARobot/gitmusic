## 一、核心工作流脚本

**所有脚本不直接读写文件系统，不直接访问远端服务器，统一根据《plan_cli》使用库实现**

### 1. **publish_meta.py**（发布元数据）
- **功能定位**：不是简单输出差异，而是**更新metadata并储存对象**（音频和封面到cache）。
- 根据输入，决定是否仅预览，是否仅处理有改动的文件（按照publish命令设计，第一次调用此脚本应该是预览模式）
- 改动对比：提取音轨并计算哈希，与metadata比对，若无匹配的`audio_oid`，视为新增，否则提取封面计算hash是否更改、提取标签进行diff
- 提取的文件、标签全部储存（使用库储存、更新元数据）后，移动已处理文件到回收站
- **输入要求**：必须接收`work_dir`和`cache_root`的位置，严禁硬编码（包括相对路径）。
- **输出要求**：
 - 标准化输出JSONL事件流（参加[《plan_cli》](plan_cli.md)）。
 - **必须输出详细的字段级变更**（标准JSONL输出，包含原始字段和新字段内容），供CLI渲染预览。
 - 不允许直接调用rich表格或进度条，以及输出任何非标内容，所有UI由CLI驱动。
- **原子操作**：使用`.tmp`文件中转，确保写入原子性。

### 2. **checkout.py**（检出音频）
- **输入要求**：通过标准输入获取路径。
- **冲突保护**：检出前若work目录已有文件且未输入`force`参数，**必须输出相应事件并退出**，防止覆盖未处理的改动。
- **文件名处理**：统一使用库将非法字符替换为下划线`_`。
- **输出**：JSONL事件流，不直接显示内容。
- 支持对应命令所需选项（从标准输入获取选项配置），[参见](命令实现规范总结.md)
- 使用库读取元数据
- 使用库获取对象路径

### 3. **create_release.py**（生成成品）
- **路径**：通过标准输入传递。
- **选项**：全部使用长选项，添加`--workers`配置线程数。
- **增量逻辑**：默认增量，通过`TXXX:METADATA_HASH`标签储存元数据哈希（直接使用metadata中对应行计算），跳过未变动文件。
- **前置操作**：生成前执行`git pull`。
- **生成范围**：支持指定生成特定条目（接收oid）（暂未在对应命令中添加选项）。
- **工作流集成**：必须先执行`sync`同步缓存，再执行`verify`校验哈希，最后生成成品（CLI层）。
- **输出**：JSONL事件流，不直接显示内容。
- 使用库读取元数据
- 使用库获取对象路径

## 二、数据管理与维护脚本

**所有脚本不直接读写文件系统，不直接访问远端服务器，统一根据《plan_cli》使用库实现**

### 4. **sync_cache.py**（同步缓存）
- **路径**：通过标准输入传递。
- **配置**：CLI层从`config.yaml`读取远程参数（例如`user`, `host`, `retries`, `timeout`），通过标准输入接收。
- **新增选项**：接收超时、线程数、方向配置（通过标准输入）。
- **同步逻辑**：双向增量同步（对比哈希），支持指数退避重试。
- **删除操作**：**sync脚本不执行删除操作**，删除由cleanup脚本处理。
- **输出**：JSONL事件流，不直接显示内容。

### 5. **verify_hashes.py**（校验哈希）
- **路径**：通过标准输入传递。
- **选项**：参见对应命令。
- **输出修正**：**不能直接调用rich表格**，必须通过标准的JSONL事件流输出错误列表，由CLI渲染表格。
- **输出格式**：JSONL事件流，包含进度、报错及其他标准状态输出。
- 全程使用库完成操作

### 6. **compress_images.py**（压缩封面）
- **输入**：通过标准输入获取路径。
- **逻辑**：仅处理大于500KB的封面（根据参数可变阈值）。
- 压缩后计算新哈希，并更新`metadata.jsonl`（使用库）。
- 压缩后不删除源文件，而是创建压缩后的新文件，并保存到对应位置
- 全程使用库完成压缩、写入操作，脚本不直接读写文件系统
- **输出**：JSONL事件流。
- 更多机制参见对应命令

### 7. **cleanup_orphaned.py**（清理孤立文件）
**核心讨论**：
- **路径**：通过标准输入JSONL传递。
- **模式选项**：根据配置，决定是否执行实际清理，若不执行清理则输出文件列表。根据配置，决定是否清理远端、是否清理本地，此配置同时影响输出的文件列表
- **输出**：JSONL事件流。

## 三、工具类脚本

**所有脚本不直接读写文件系统，不直接访问远端服务器（URL除外），统一根据《plan_cli》使用库实现**

### 8. **download_ytdlp.py**（下载音频）
**核心讨论**：
- **路径**：通过标准输入传递。
- **预览功能**：根据命令需求，获取元数据后，使用标准输出传递元数据（时长、比特率、标题等）。
- **批处理**：若标准输入中包含批处理列表文件路径，使用库读取（期望每行一个URL，忽略无法识别行，若文件为空或无可识别行，报错退出）。
- **yt-dlp输出处理**：捕获yt-dlp的原始输出，转发到标准输出，用于CLI打印下载进度。
- **输出**：JSONL事件流。

### 9. **analyze_metadata.py**（元数据分析）
**核心讨论**：
- **路径**：通过库读取元数据，不涉及路径。
- 具体功能参见[《命令实现规范总结》](命令实现规范总结.md)
- **输出**：JSONL格式的结果（匹配的条目列表或统计信息）。

### 10. **analyze_duplicates.py**（重复项分析）
**核心讨论**：
- **路径**：通过标准输入传递。
- **功能**：分析OID和文件名的重复情况。
- **输出**：JSONL格式的重复项报告。

## 四、关键实现原则总结

1. **零硬编码路径**：所有脚本通过标准输入获取路径，配置文件（`config.yaml`）使用绝对路径。
2. **标准化I/O**：所有脚本必须输出JSONL事件流，**禁止直接调用rich的表格或进度条**，所有UI由CLI渲染。
3. **零选项**：所有脚本全部使用标准输入接收配置。
4. **原子操作**：文件写入使用库；同步操作使用库进行原子传输。
5. **工作流集成**：核心命令（publish, download, release）必须在CLI中集成完整的自动化工作流（压缩、校验、同步、提交）。
6. **配置驱动**：远程参数（user, host, retries, timeout）从CLI输入。
7. **错误处理**：通过`EventEmitter.error`输出错误，由CLI决定是继续还是停止。
