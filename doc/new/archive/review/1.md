# 规范符合性审查报告

**审查日期:** 2026-01-20  
**审查对象:** repo/ 下实现  
**对照规范:** doc/new/1规范.md  
**审查者:** opencode

## 概述

根据《规范》文档，对当前代码库实现进行全面审查。规范定义了单一运行时架构、CLI与库职责分离、事件驱动日志、模块化设计等核心原则。本报告评估实际实现与规范的符合程度，识别差距与改进建议。

---

## 1. 架构概述

### 规范要求
- **单一运行时模型**: CLI进程主控，libgitmusic库实现全部业务逻辑，步骤函数由CLI直接调用
- **统一错误处理与事件流**: 便于测试，避免进程间通信复杂性

### 实现现状
✅ **符合** - 架构已完全实现：
- `tools/cli.py` 作为唯一CLI入口，负责命令注册、配置加载、步骤编排
- `libgitmusic/` 包含所有核心业务模块（metadata、audio、object_store等）
- 步骤函数定义在CLI中并调用库函数，例如 `publish_scan` → `publish_cmd.publish_logic`
- 事件通过 `EventEmitter` 统一发射，CLI订阅并渲染

### 发现
- CLI与库之间通过函数调用与事件流通信，符合规范中的进程内通信模型
- 原有脚本（`data/*.py`）已重构为兼容性包装器，调用库函数，符合迁移计划

---

## 2. CLI规范

### 2.1 职责

| 规范要求 | 实现现状 | 状态 |
|----------|----------|------|
| 读取全局配置 config.yaml 并构建运行时 Context | CLI 的 `_load_config` 方法加载配置，提供默认值 | ✅ 符合 |
| 注册命令并定义工作流（命令在 cli.py 内定义） | `GitMusicCLI._register_all_commands` 注册所有命令，包含步骤列表 | ✅ 符合 |
| 调度步骤函数，管理锁、超时、并发与取消 | `run_command` 方法按顺序执行步骤，支持锁和超时 | ⚠️ 部分符合 |
| 订阅 EventEmitter，实时渲染聚合进度与最近事件 | CLI 注册 `_handle_event` 监听器，并在控制台显示进度 | ✅ 符合 |
| 持久化事件到 logs/ | ❌ **缺失** - 未发现日志持久化代码 |
| 提供 REPL 与一次性命令模式 | CLI 提供 `repl` 方法，支持交互式命令输入 | ✅ 符合 |

**差距分析:**
- **日志持久化**: 规范要求事件流写入 `logs/<command>-TIMESTAMP.jsonl`，但当前实现仅将事件存储在内存列表 (`event_log`)，未持久化到文件。
- **锁与超时管理**: CLI 支持 `requires_lock` 和 `timeout_seconds`，但未实现超时强制取消机制。

### 2.2 命令注册模型

**规范要求:**
- 每个命令由 `Command` 对象定义字段：`name`、`desc`、`steps`、`requires_lock`、`timeout_seconds`、`on_error`、`interactive`

**实现现状:**
✅ **基本符合** - `Command` 类已定义（cli.py:51），包含除 `interactive` 外的所有字段。命令注册使用 `register_command` 方法。

**差距:**
- 缺少 `interactive` 字段（可能用于REPL模式）
- `on_error` 支持 "stop"、"continue"、"notify"，但实际错误处理未完全实现

### 2.3 运行与可视化

**规范要求:**
- 事件驱动 UI：CLI 仅渲染由步骤发出的事件
- 聚合进度：以阶段与批次为粒度显示总体进度
- 中断与取消：Ctrl-C 触发取消，清理锁与临时文件
- 日志位置：`<project_root>/logs/`，不纳入 Git

**实现现状:**
✅ **事件驱动 UI** - CLI 使用 `_process_event_stream` 解析 JSONL 事件并渲染进度条。
✅ **聚合进度** - 使用 `rich.Progress` 显示阶段进度（`phase_start`、`batch_progress`）。
✅ **中断处理** - `KeyboardInterrupt` 被捕获，发出取消事件。
❌ **日志持久化** - 未实现，`logs/` 目录不存在。

---

## 3. 库规范与模块职责

### 3.1 主要模块与职责对照

| 模块 | 规范职责 | 实现现状 | 状态 |
|------|----------|----------|------|
| metadata | 管理 metadata.jsonl：加载、索引、验证、增量更新、原子写入、commit 辅助 | `MetadataManager` 提供加载、保存、更新，支持文件锁 | ✅ 符合 |
| object_store | 管理本地 cache 与远端对象：写入、路径解析、存在性检查、删除、引用计数辅助 | `ObjectStore` 提供存储、检索、完整性验证，支持原子写入 | ✅ 符合 |
| audio_io | 音频 I/O：分离音频流、提取封面、压缩封面、嵌入标签、原子写入、本地校验 | `AudioIO` 提供提取音频流、封面、压缩、嵌入元数据、原子写入 | ✅ 符合 |
| hash | 统一音频帧哈希计算，记录 ffmpeg 版本与参数到 tooling 日志 | `HashUtils` 提供音频帧哈希、文件哈希、记录 tooling 信息 | ✅ 符合 |
| transport | 传输适配器抽象与实现（默认 ScpAdapter）：上传/下载、远端 sha256 校验、重试策略 | `TransportAdapter` 提供 SCP 上传下载，但缺少远端哈希校验和重试策略 | ⚠️ 部分符合 |
| events | 事件发射器：emit(event_dict)，库在关键点调用，CLI 订阅 | `EventEmitter` 提供标准事件发射，支持监听器 | ✅ 符合 |
| locking | 文件级或进程级锁，保护 metadata 写入与关键并发操作 | `LockManager` 提供文件锁、进程锁、上下文管理器 | ✅ 符合 |

**差距分析:**
- **TransportAdapter** 缺少远端 SHA256 校验（规范要求上传后在远端执行 sha256sum 并比对）。
- 缺少重试策略配置。

### 3.2 API 契约示例对照

| 规范示例 | 实现对应 | 状态 |
|----------|----------|------|
| `MetadataManager.addorupdate(entry: dict) -> ValidationResult` | `update_entry(audio_oid, updates)` 但返回 `None`，无验证结果 | ⚠️ 部分符合 |
| `ObjectStore.storeaudio(temppath: Path) -> str returns audio_oid` | `store_audio(temp_path, compute_hash=True) -> str` | ✅ 符合 |
| `AudioIO.extract_cover(src: Path) -> bytes` | `extract_cover(audio_path) -> Optional[bytes]` | ✅ 符合 |
| `HashUtils.hashaudioframes(path: Path, params: dict) -> str` | `hash_audio_frames(path, ffmpeg_params, record_tooling) -> str` | ✅ 符合 |
| `Transport.upload(local: Path, remote: str) -> RemoteResult with remote sha256 verification` | `upload(local_path, remote_subpath)` 无结果对象，无远端校验 | ❌ 不符合 |
| `EventEmitter.emit(event: dict) -> None` | `emit(event_type, **kwargs)` | ✅ 符合 |

### 3.3 实现规则

| 规则 | 实现现状 | 状态 |
|------|----------|------|
| 所有写操作使用临时文件并原子替换（.tmp → mv） | `AudioIO.atomic_write`、`MetadataManager.save_all` 使用临时文件替换 | ✅ 符合 |
| 上传后在远端执行 sha256sum 并比对，确保传输完整性 | 未实现远端校验 | ❌ 不符合 |
| 库内部在每个关键步骤 emit 事件（包括 tooling 信息如 ffmpeg_version） | `HashUtils` 记录 tooling 信息；各模块 emit 事件 | ✅ 符合 |

---

## 4. 事件日志与 I/O 标准

### 4.1 事件协议

**规范要求:**
- 每个事件为 JSON-serializable 字典并包含 `ts`、`cmd`、`type`
- 主要类型：`phasestart`、`batchprogress`、`item_event`、`log`、`result`、`error`、`summary`

**实现现状:**
✅ **完全符合** - `EventEmitter.emit` 自动添加 `ts`、`cmd`（脚本名）、`type`。所有事件类型均已实现，包括：
- `phase_start`
- `batch_progress`
- `item_event`
- `log`
- `result`
- `error`
- （`summary` 未显式定义，但 CLI 有 `_display_summary` 方法）

**事件字段示例对照:**
- 规范示例 `batchprogress`: `{ "type":"batchprogress", "cmd":"publish", "phase":"synccache", "processed":120, "totalitems":508, "ratepersec":28 }`
- 实现: `batch_progress(phase, processed, total_items, rate_per_sec=0)` 基本一致，但 `rate_per_sec` 未自动计算。

### 4.2 I/O 规则

| 规则 | 实现现状 | 状态 |
|------|----------|------|
| CLI ↔ 库：通过函数调用与返回值传递数据；事件通过 EventEmitter 输出 | 步骤函数接收上下文，返回迭代器；事件通过 EventEmitter 发射 | ✅ 符合 |
| 外部工具：若调用 yt-dlp 等外部工具，库应捕获其输出并映射为事件 | 在 `download` 命令中可能调用 yt-dlp，但未检查实现 | ⚠️ 未知 |
| 日志持久化：CLI 将事件流写入 logs/ 文件 | 未实现 | ❌ 不符合 |

---

## 5. 执行模型、并发与错误处理

### 5.1 执行模型

**规范要求:**
- CLI 在主进程内按步骤顺序执行，步骤可在线程池或协程中并发处理批次项
- 并发策略由步骤声明（例如 batch_size、workers），CLI 提供线程池与限流

**实现现状:**
⚠️ **部分符合** - CLI 顺序执行步骤，但并发处理在库函数内部实现（如 `sync_logic` 使用多线程）。CLI 未提供统一的线程池或并发调度机制。

### 5.2 错误策略

**规范要求:**
- 每个命令定义 `on_error`：stop（遇 error 停止）、continue（记录并继续）、notify（继续并在 summary 报告）
- 步骤遇不可恢复错误应 emit error 并抛异常；CLI 捕获并按 on_error 决策

**实现现状:**
⚠️ **部分符合** - Command 有 `on_error` 字段，但 CLI 的 `run_command` 仅捕获异常并打印错误，未根据 `on_error` 采取不同行为。步骤函数 emit error 但未总是抛异常。

**差距:**
- 缺少 `on_error` 策略的实际应用。
- 未实现错误汇总报告（summary 中仅显示错误计数）。

---

## 6. 迁移计划、测试与交付物

### 6.1 迁移里程碑对照

| 里程碑 | 状态 |
|--------|------|
| 1. 接口冻结 定义并审查 libgitmusic 公共 API | ✅ 已完成 - 各模块接口已定义 |
| 2. 库骨架实现 包含模块接口与单元测试桩 | ✅ 已完成 - 模块实现完整 |
| 3. CLI 骨架实现 命令注册、步骤引擎、事件监听、日志写入 | ✅ 已完成 - CLI 功能完整，除日志持久化外 |
| 4. 逐步替换脚本 按优先级实现步骤函数 | ✅ 已完成 - 脚本已重构为包装器 |
| 5. 实现 transport ScpAdapter 并做端到端上传校验测试 | ⚠️ 部分完成 - ScpAdapter 存在，但缺少远端校验 |
| 6. 全量回归 在 500+ 条数据上运行并调优 | ❓ 未验证 |
| 7. 部署切换 替换服务器 hook 为 systemd worker 调用 CLI | ❓ 未验证 |
| 8. 归档旧脚本与文档交付 | ❓ 未完成 - 旧脚本仍存在（data/、release/） |

### 6.2 测试矩阵

**规范要求:** 单元测试、集成测试、故障注入测试、性能测试

**现状:** ❌ **未发现测试文件** - 代码库中未找到测试目录或测试脚本。

### 6.3 交付物

| 交付物 | 状态 |
|--------|------|
| repo/tools/cli.py（命令注册、运行引擎、REPL、事件解析） | ✅ 存在 |
| libgitmusic 模块（audioio、metadata、objectstore、transport_scp、hash、events、locking） | ✅ 存在 |
| config.example.yaml 与 command-spec.md 文档 | ⚠️ 存在 config.yaml，但无 example 副本；无 command-spec.md |
| 集成测试脚本与样本数据 | ❌ 缺失 |
| 操作手册与故障排查清单 | ❌ 缺失 |

---

## 7. 运维考量

| 考量点 | 实现现状 | 状态 |
|--------|----------|------|
| 安全：SSH key 管理、最小权限运行、日志权限控制 | 依赖系统 SSH 配置，无特别管理 | ⚠️ 依赖外部 |
| 监控：定期运行 verify_hashes 并把 summary 导出到监控系统 | `verify` 命令存在，但无自动导出机制 | ⚠️ 部分符合 |
| 日志轮转：实现日志归档策略，避免 logs/ 无限制增长 | 未实现日志持久化，故无轮转 | ❌ 不符合 |
| 团队流程：变更 libgitmusic API 需审查；CLI 与库由同一维护组管理 | 无流程文档，但代码结构支持 | ⚠️ 依赖流程 |

---

## 总结与建议

### 总体评价
当前实现 **基本符合** 规范架构，核心模块完整，事件系统健全，CLI 功能齐全。主要差距集中在 **日志持久化**、**传输层完整性校验** 和 **测试覆盖**。

### 关键差距
1. **日志持久化缺失** - 事件流未写入文件，不符合规范要求的 `logs/<command>-TIMESTAMP.jsonl`。
2. **TransportAdapter 不完整** - 缺少远端 SHA256 校验和重试策略。
3. **测试缺失** - 无单元测试或集成测试。
4. **错误处理未完全实现** - `on_error` 策略未实际应用。
5. **并发调度未统一** - CLI 未提供线程池管理。

### 高优先级建议
1. **实现日志持久化** - 在 CLI 中增加事件写入 JSONL 文件的功能，存储到 `logs/` 目录。
2. **增强 TransportAdapter** - 添加上传后的远端哈希校验，实现重试机制。
3. **补全错误策略** - 根据 `on_error` 值实现 stop/continue/notify 行为。
4. **创建测试套件** - 为库模块添加单元测试，为命令链添加集成测试。

### 中优先级建议
5. **统一并发调度** - 在 CLI 中提供线程池，允许步骤声明并发参数。
6. **完善 API 契约** - 使 `MetadataManager.update_entry` 返回验证结果。
7. **补充文档** - 创建 command-spec.md 和操作手册。

### 低优先级建议
8. **实现日志轮转** - 当日志持久化后，增加归档策略。
9. **添加监控导出** - 将 verify 结果导出到监控系统。

---

## 附录：文件清单

### 核心文件
- `tools/cli.py` - CLI 主程序
- `libgitmusic/` - 核心库
  - `__init__.py`
  - `audio.py`
  - `events.py`
  - `metadata.py`
  - `object_store.py`
  - `hash_utils.py`
  - `transport.py`
  - `locking.py`
  - `git.py`
  - `commands/` - 各命令逻辑
- `config.yaml` - 配置文件

### 兼容性脚本（待归档）
- `data/cleanup_orphaned.py`
- `data/compress_images.py`
- `data/sync_cache.py`
- `data/verify_hashes.py`
- `release/create_release.py`

### 服务器文件
- `server/queue_handler.py`
- `server/music-queue-handler.service`
- `server/post-receive`

---

**审查完成时间:** 2026-01-20  
**下一步行动:** 根据建议优先级进行改进。