结论要点
- 路径传递与解析：必须由 CLI 构建并注入到运行时 Context（或 ctx），库函数只接受 Path/字符串参数并不自行查找配置文件位置。所有路径应为绝对路径或由 Context 明确解析后的路径。  
- 库函数职责边界：libgitmusic 负责所有确定性 I/O（本地文件读写、临时文件、原子替换）和远端访问（通过 Transport 适配器），并在关键点 emit 事件与返回结构化结果；CLI 负责调度、用户交互、渲染与决定何时调用库。  
- 谁做文件系统/远端操作：库函数应直接执行文件系统与远端操作，但通过抽象层（object_store、transport）完成，避免在库外再重复实现。脚本/步骤不直接做低级 I/O，而是调用库 API。  
- 安全、原子性、并发：库必须实现临时文件写入 + mv 原子替换、fsync、锁（LockManager）、远端 sha256 校验、重试与幂等性策略。CLI 不承担这些细节。  

下面把这些规则分项、明确地列出来，便于开发与审计。

---

1) 路径传递与解析标准（必须遵守）
- 单一入口解析：CLI 在启动时读取 config.yaml（路径可由 GITMUSICCONFIG 环境变量覆盖），并构建 Context：包含 projectroot、workdir、cachedir、releasedir、logsdir、tmp_dir、transport 配置等。  
- 绝对路径：所有传入库函数的路径必须是绝对路径。若用户在 CLI 提供相对路径，CLI 负责把它解析为绝对路径（基于 project_root 或当前工作目录）。  
- 禁止库自行查找 config：库函数不得自行读取或搜索 config.yaml；若需要配置，必须通过 Context 参数传入。  
- 路径验证：CLI 在注入前应做基本验证（存在性、权限、是否为目录/文件）；库在执行前再次校验并在不满足时 emit error 并抛出 ValidationError。  
- 临时路径约定：库写入临时文件时使用 ctx.tmp_dir 或 Path(tempfile.mkdtemp(...))，临时文件命名应包含命令名与 PID，避免冲突。  
- 符号链接与安全：库在写入关键目录前应检测并拒绝不安全的 symlink（或按配置允许但记录警告），避免 TOCTOU 攻击。

---

2) 库函数应否直接操作文件系统与远端 — 明确规则
- 结论：是，库函数应直接操作本地文件系统与远端，但必须通过明确的抽象与契约（object_store、transport、locking）完成，且遵守原子性、幂等性与校验规则。  
- 理由：把 I/O 与一致性逻辑集中在库中可以保证行为一致、便于测试、避免脚本重复实现、并能在库层统一实现重试/回滚/校验策略。  
- 如何实现：  
  - 本地 I/O：由 objectstore、metadata、audioio 等模块负责（写 tmp → fsync → mv → fsync parent）。  
  - 远端 I/O：由 transport 抽象（ScpAdapter 等）负责，库通过 transport.upload/download 调用远端操作并在返回后做比对。  
  - 事件与返回：每次关键 I/O 成功/失败前后，库 events.emit() 对应事件并返回结构化结果对象（含路径、oid、status）。  
- 脚本/步骤的角色：脚本（或 CLI 的步骤函数）不直接做低级 I/O（例如直接调用 scp、直接写 metadata.jsonl），而是调用库 API。脚本只负责组合步骤、处理用户确认与渲染。

---

3) 文件系统读写与原子性规范（库必须实现）
- 写入模式（必须）：所有对持久化目标（metadata.jsonl、release 文件、cache 对象）写入遵循：  
  1. 写入到临时文件 target.tmp（同目录或指定 tmp_dir）  
  2. fsync 临时文件（确保数据落盘）  
  3. os.replace() / mv 原子替换到目标路径  
  4. fsync 目标目录（确保目录元数据落盘）  
- 元数据写入锁：在写 metadata.jsonl 或任何共享索引前必须 locking.acquire("metadata", timeout)，写完后 release。  
- 权限与所有权：写入后设置文件权限与所有者（由 config 指定或继承运行用户），并记录到事件（artifacts）。  
- 回滚策略：若写入或后续步骤失败，库应清理临时文件并 emit error，但不尝试自动恢复旧版本（除非明确实现事务/备份机制）。

---

4) 远端访问与校验规范（库必须实现）
- 抽象层：所有远端交互通过 transport 抽象（ScpAdapter、S3Adapter 等）。CLI/脚本不直接调用 scp。  
- 上传流程（必须）：  
  1. 本地写 obj.tmp → fsync  
  2. transport.upload(localtmp, remotetmp) 上传到远端临时路径  
  3. 在远端执行 sha256sum remote_tmp（由 transport 实现）并返回远端哈希  
  4. 本地计算本地哈希并比对远端哈希；若一致，远端 mv remotetmp remotefinal（原子）并设置权限；若不一致，重试或报错。  
- 下载流程（必须）：下载到本地 .part → 本地计算哈希 → 比对期望 → mv 到最终路径。  
- 重试与退避：transport 实现应支持可配置的重试次数、指数退避与超时。失败时 emit error 并返回明确错误类型。  
- 幂等性：若远端目标已存在且哈希匹配，上传操作应短路并返回成功（避免重复上传）。  
- 安全：使用 SSH key 或受管凭据；transport 不在日志中写出敏感凭据。

---

5) 路径与权限的具体约定（实现细节）
- 路径类型：库 API 接受 Path 或字符串，但内部立即转换为 Path 并调用 resolve()（不跟随不安全 symlink 除非配置允许）。  
- 默认目录：若 ctx 未提供某路径，库应抛出 ConfigurationError；不应使用硬编码默认路径。  
- 临时目录策略：优先使用 ctx.tmp_dir；若不存在，使用 tempfile.mkdtemp(prefix="gitmusic-") 并在操作结束清理（或按 config 保留用于调试）。  
- 权限检查：在写入前检查目标目录可写性与磁盘空间（阈值可配置），不足时 emit error 并中止。  
- 跨平台注意：路径处理应兼容 POSIX 与 Windows（使用 pathlib），但 transport/permissions 在 Windows 上可能有不同实现，需在适配器中处理。

---

6) 事件、返回值与错误契约（与路径/IO 相关）
- 事件包含路径信息：成功写入或上传后 itemevent 必须包含 localpath、remote_path（若适用）、oid、size、permissions。  
- 返回结构：库函数返回结构化对象（例如 StoreResult{audiooid, localpath, uploaded, remote_path}），CLI 根据返回决定下一步。  
- 错误类型：定义明确异常类：ValidationError（路径/参数问题）、IOError（本地 FS 问题）、TransportError（远端问题）、LockError（锁获取失败）。库在抛出前 emit error 事件。  
- 日志：所有事件写入运行日志（JSONL），包含路径与状态，但不得写入敏感凭据。

---

7) 实施与验收检查清单（开发/审计用）
- 路径注入：CLI 是否把 projectroot、workdir、cachedir、releasedir、logsdir、tmpdir 注入 Context？（是/否）  
- 绝对路径：库函数接收到的路径是否为绝对路径？（是/否）  
- 临时写入：所有写操作是否遵循 tmp -> fsync -> mv -> fsync(parent)？（是/否）  
- 锁使用：metadata 写入是否在锁保护下？（是/否）  
- 远端校验：上传后是否做远端 sha256 校验并比对本地？（是/否）  
- 幂等性：重复 store_audio 对相同 oid 是否短路？（是/否）  
- 错误事件：库在失败前是否 emit error 并抛出明确异常？（是/否）  
- 权限检查：写入前是否检查目录可写性与磁盘空间？（是/否）  
- 日志敏感信息：日志中是否避免写入凭据或密钥？（是/否）

---

简短示例（约定式伪签名，便于实现）
`python

CLI 构建 Context（示例）
ctx = Context(
  project_root=Path("/srv/gitmusic"),
  work_dir=Path("/srv/gitmusic/work").resolve(),
  cache_dir=Path("/srv/gitmusic/cache").resolve(),
  release_dir=Path("/srv/gitmusic/release").resolve(),
  tmp_dir=Path("/tmp/gitmusic").resolve(),
  transport=ScpAdapter(...),
  events=EventEmitter(logfile=...),
  locking=LockManager(...)
)

库函数签名示例（路径为绝对 Path）
def storeaudio(temppath: Path, ctx: Context) -> StoreResult:
    # validate temp_path absolute, write to cache tmp, fsync, upload via ctx.transport, verify remote sha256
    ...
`

---

最后说明（为什么这样）
- 集中 I/O 与一致性逻辑到库 能保证行为一致、便于测试与审计；CLI 保持轻量、专注交互与渲染。  
- 路径由 CLI 解析并注入 避免库在不同环境下自行查找配置或使用隐式相对路径，减少错误与安全风险。  
- 库直接做 FS/远端操作但通过抽象（object_store/transport/locking）实现可替换性与可测试性，同时满足原子性、幂等性与安全要求。
